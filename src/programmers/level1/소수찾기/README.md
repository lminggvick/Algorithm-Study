## '소수 개수 구하기'

https://programmers.co.kr/learn/courses/30/lessons/12921
___

- 1차 풀이 

```
for (i -> 1부터 n까지) {
    for (j -> 1부터 i까지) {
        if (i % j == 0) {
            i = 소수가 아니다 (false)
            break;
        }
    }
}
```

**문제점)** 시간 복잡도의 효율성이 좋지 않아 '시간초과'가 뜨는 케이스들이 존재함

- 2차 풀이

```
for (i -> 1부터 n까지) {
    if (i % 2 == 0) {
        i = 소수가 아니다 (false)
    }
    
    if (i % 3 == 0) {
        i = 소수가 아니다 (false)
    }
    
    for (j -> 1부터 i까지) {
       ... (동일)
    }
}
```

**문제점)** 2와 3의 배수만 2차 루프를 돌지 않아서 약간의 효율성은 올라갔지만, 여전히 '시간초과' 발생


- 3차 풀이 **( 에라토스테네스의 체 )**

```
- 1부터 N까지 모든 리스트에 true 값을 넣는다.
- 0과 1은 소수가 아니므로 false 로 초기화
- 2부터 n 까지 루프를 돌면서 배수값에 해당하는 List 는 모두 false 로 바꿔준다.
```

**의문점)**

1. for (int i = 2; i * i <= n; i++) 구문에서, i * i <= n 까지 도는 이유
 -> 배수를 제거해 나가다 보면, 결국 i * i 이상의 소수는 주어진 범위를 초과하는 수 이기 때문.

2. for (int j = i * i; j <= n; j += i) 구문에서, 초기값을 i * i 로 두는 이유
 -> 3의 배수를 제거하는 루프라고 할 때, 1) 3은 소수이므로 제거 해선 안되고, 2) 6의 경우 이미
 2의 배수를 제거 할 때 제거가 되었기 때문임
 
 따라서, i * i 미만의 수의 경우는 앞의 루프에서 이미 false 로 처리 되었기 때문에 불필요하게 루프를 돌필요가 없음

**참고)**

에라토스테네스의 체 - https://namu.wiki/w/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%20%EC%B2%B4
